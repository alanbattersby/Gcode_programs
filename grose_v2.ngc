(  GRose - a program to simulate a simple rose engine			)
(  Created By:  Alan Battersby	August 2011				)
 
(  This program is free software: you can redistribute it and/or modify )
(  it under the terms of the GNU General Public License as published by )
(  the Free Software Foundation, either version 3 of the License, or	)
(  [at your option] any later version.					)

(    This program is distributed in the hope that it will be useful,	)
(    but WITHOUT ANY WARRANTY; without even the implied warranty of	)
(    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	)
(    GNU General Public License for more details.			)
(	see <http://www.gnu.org/licenses/>				)

(	Main Table starting locations )
#<_Main_Count>		= #200	( Number of Rosettes on Main		)
#<_MainSpindle>		= 200	( start of Rosettes on Main Spindle	)
				( data starts at #<_MainSpindle + 1>	)
#<_Pump_Count>		= #400	( Number of stages on Pump		)
#<_PumpSpindle>		= 401

#<_Chuck_Count>		= #600	( Number of stages on Chuck		)
#<_Chuck>		= 600	( start of stages on chuck		)

#<_Rosette_Count>	= #800	( first item is count of rosettes	)
#<_Rosettes>		= 801	( start of rosette data			)
#<_RosettesOffset>	= 10	( record size for Rosette		)

#<_Surface>		= #2000	( start of surface/ profile data	)

#<_result>	= #31	( General scalar result				)
#<_resultA>	= #32	( this with #31 is polar of radius		)
#<_resultX>	= #33	( X coordinate of vector result 		)
#<_resultY> 	= #34	( Y coordinate of vector result 		)
#<_resultZ> 	= #35	( Z coordinate of vector result 		)

( Main Program locations						)
#<_UseRotary>		= #49	(flag is 1 if a rotary machine		)
#<_UseMainSpindle>	= #50	(flag is 1 if using main spindle	)
#<_UsePumpSpindle>	= #51	(flag is 1 if using pump spindle	)
#<_UseChuck>		= #52	(flag is 1 if using chuck		)
#<_UseSurface>		= #53	(flag is 1 if using surface		)
#<_ToolOffset>		= #54	(tool offset position			)
#<_UseBlending>		= #55	( flag is 1 if using blending		)
#<_InvFeedrate>		= #56	( inverse feed rate			)
#<_Feedrate>		= #57	(Linear feed rate			)
#<_Safeheight>		= #58	(safe height				)
#<_Winding> 		= #59	( number of turns around origin		)
#<_XScale>		= #60	( scaling factor for x direction	)
#<_YScale>		= #61	( scaling factor for y direction	)
#<_ZScale>		= #62	( scaling factor for z direction	)

( Use type to call correct function		)
( Fill in dispatch table			)
#40 = 100	(Elliptical Rosette  	Type 0	)
#41 = 150	(Polygon Rosette 	Type 1	)
#42 = 200	(Wave Rosette		Type 2	)
#43 = 250	(Epicycloid Rosette 	Type 3	)
#44 = 300	(Hypocycloid Rosette	Type 4	)
#45 = 350	(Spiral Rosette		Type 5	)
#46 = 400  	(Petal Rosette		Type 6	)
#47 = 450	(Unused Rosette		Type 7	)

(Basic Rosettes that take their values from a memory block	 	)
(Common Offsets								)
(  R_Type        = 0;    // type of rosette				)
(  R_Include     = 1;    // flag to include rosette			)
(  R_R           = 2;    // Major radius of rosette			)
(  R_r           = 3;    // Minor radius of rosette			)
(  R_Phase       = 4;    // phase of rosette				)
(  R_Blend       = 5;    // blend coefficient				)

(  Polygon Rosette							)
(  R_Numsides    = 6;    // number of sides in polygon			)
(  R_IsStar      = 7;    // flag true if star shape			)

(  Petal Rosette 							)
(  R_Numsides	 = 6;	// number of sides of petal			)

(  Wave Rosette								)
(  R_Frequency   = 6;    // frequency of wave				)
(  R_Amplitude   = 7;    // Amplitude of wave				)
(  R_Absolute    = 8;    // flag set true if absolute values used	)

(  Spiral Rosette							)
(  a             = 2;    // start radius				)
(  b             = 3;    // r = a + b * angle				)
(									)
(sub to display rosette data )
o<Display_Rosette> sub (#1 is base address of rosette)
	#2 = ##1
	#3 = #[#1 + 5]
	(debug, rosette base = #1 type = #2 blend = #3)
o<Display_Rosette> endsub
	

(---------- first code to create various types of Rosette --------------)
o<CreateEllipticalRosette> sub	(#1 is the Major radius			)
				(#2 is the Minor radius			)
				(#3 is the phase			)
				(#4 is the blending value		)
				(#8 is local base addr of data block	)

	( first get index of next free rosette space in memory		)
	#8 = [#<_Rosettes> + [#<_Rosette_Count> * #<_RosettesOffset>]]
	##8		= 0  (Type of rosette 				)
	#[#8 + 1] 	= 1  (Include this rosette 			)
	#[#8 + 2]  	= #1 (Major radius				)
	#[#8 + 3]	= #2 (Minor radius				)
	#[#8 + 4]  	= #3 (Phase of rosette				)
	#[#8 + 5]	= #4 (Blend					)
	
	#<_result> = [#8]  ( return addr of this rosette 		)	
	#<_Rosette_Count> = [#<_Rosette_Count> + 1]				
o<CreateEllipticalRosette> endsub

o<CreateWaveRosette> sub	(#1 is the Radius			)
				(#2 is the Frequency			)
				(#3 is the Amplitude			)
				(#4 is the abs value			)
				(#5 is the phase flag			)
				(#6 is the blend flag			)
				(#8 is local base addr of data block	)
	( first get index of next free rosette space in memory		)
	#8 = [#<_Rosettes> + [#<_Rosette_Count> * #<_RosettesOffset>]]
	##8 	= 2  (Type of rosette 				)
	#[#8 + 1]  = 1  (Include this rosette 			)
	#[#8 + 2]  = #1 (Major radius				)
	#[#8 + 3]  = 0  (none					)
	#[#8 + 4]  = #5 (Phase of rosette			)
	#[#8 + 5]  = #6 (Blend					)
	#[#8 + 6]  = #2 (frequency				)
	#[#8 + 7]  = #3 ( Amplitude				)
	#[#8 + 8]  = #4 ( Absolute value			)
	#<_result> = [#8]  ( return addr of this rosette 	)	
	#<_Rosette_Count> = [#<_Rosette_Count> + 1]				
o<CreateWaveRosette> endsub

o<CreatePolyRosette> sub  	(#1 is the Major Radius			)
				(#2 is the Minor radius for star	)
				(#3 is the Number of sides		)
				(#4 is the star flag			)
				(#5 is the phase			)
				(#6 is the blend flag			)
				(#8 is local base addr of data block	)
	( first get index of next free rosette space in memory		)
	#8 = [#<_Rosettes> + [#<_Rosette_Count> * #<_RosettesOffset>]]
	##8 	= 1  	(Type of rosette 				)
	#[#8 + 1]  = 1  (Include this rosette 			)
	#[#8 + 2]  = #1 (Major radius				)
	#[#8 + 3]  = #2 (Minor or star radius			)
	#[#8 + 4]  = #5 (Phase of rosette			)
	#[#8 + 5]  = #6 (Blend					)
	#[#8 + 6]  = #3 (Num sides				)
	#[#8 + 7]  = #4 (is star				)
	#<_result> = [#8]  ( return addr of this rosette 	)	
	#<_Rosette_Count> = [#<_Rosette_Count> + 1]				
o<CreatePolyRosette> endsub


o<CreatePetalRosette> sub  	(#1 is the Major Radius			)
				(#2 is the Minor radius for star	)
				(#3 is the Number of sides		)
				(#4 is the Phase			)
				(#5 is the blend flag			)
				(#8 is local base addr of data block	)
	( first get index of next free rosette space in memory		)
	#8 = [#<_Rosettes> + [#<_Rosette_Count> * #<_RosettesOffset>]]
	##8 	= 6  	(Type of rosette 				)
	#[#8 + 1]  = 1  (Include this rosette 			)
	#[#8 + 2]  = #1 (Major radius				)
	#[#8 + 3]  = #2 (Minor or star radius			)
	#[#8 + 4]  = #4 (Phase of rosette			)
	#[#8 + 5]  = #5 (Blend					)
	#[#8 + 6]  = #3 (Num sides				)
	#<_result> = [#8]  ( return addr of this rosette 	)	
	#<_Rosette_Count> = [#<_Rosette_Count> + 1]				
o<CreatePetalRosette> endsub

o<CreateEpiRosette> sub	(#1 is the Major Radius			)
			(#2 is the Minor radius for circle	)
			(#3 is the Phase			)
			(#4 is the Blend			)
			(#8 is local base addr of data block	)
	( first get index of next free rosette space in memory		)
	#8 = [#<_Rosettes> + [#<_Rosette_Count> * #<_RosettesOffset>]]
	##8 	= 3  	(Type of rosette 				)
	#[#8 + 1]  = 1  (Include this rosette 			)
	#[#8 + 2]  = #1 (Major radius				)
	#[#8 + 3]  = #2 (Minor or star radius			)
	#[#8 + 4]  = #3 (Phase of rosette			)
	#[#8 + 5]  = #4 (Blend					)
	#<_result> = [#8]  ( return addr of this rosette 	)	
	#<_Rosette_Count> = [#<_Rosette_Count> + 1]				

o<CreateEpiRosette> endsub

o<CreateHypoRosette> sub (#1 is the Major Radius		)
			(#2 is the Minor radius 		)
			(#3 is the Phase			)
			(#4 is the blend flag			)
			(#8 is local base addr of data block	)
	( first get index of next free rosette space in memory		)

	#8 = [#<_Rosettes> + [#<_Rosette_Count> * #<_RosettesOffset>]]
	##8 	= 4  	(Type of rosette 				)
	#[#8 + 1]  = 1  (Include this rosette 			)
	#[#8 + 2]  = #1 (Major radius				)
	#[#8 + 3]  = #2 (Minor or star radius			)
	#[#8 + 4]  = #3 (Phase of rosette			)
	#[#8 + 5]  = #4 (Blend					)
	#<_result> = [#8]  ( return addr of this rosette 	)	
	#<_Rosette_Count> = [#<_Rosette_Count> + 1]				

o<CreateHypoRosette> endsub

o<CreateSpiralRosette> sub 
			(param #1 is a				)
			(param #2 is b				)
			(param #3 is the Phase			)
			(param #4 is the Blend			)

			(local #8 is base addr of data block	)
	( first get index of next free rosette space in memory	)

	#8 = [#<_Rosettes> + [#<_Rosette_Count> * #<_RosettesOffset>]]
	##8 	= 5  	(Type of rosette 			)
	#[#8 + 1]  = 1  (Include this rosette 			)
	#[#8 + 2]  = #1 (Major radius				)
	#[#8 + 3]  = #2 (Minor or star radius			)
	#[#8 + 4]  = #3 (Phase of rosette			)
	#[#8 + 5]  = #4 (Blend					)
	#<_result> = [#8]  ( return addr of this rosette 	)	
	#<_Rosette_Count> = [#<_Rosette_Count> + 1]				


o<CreateSpiralRosette> endsub

o<AddRosetteToSpindle> sub  	(#1 is spindle address			)
				(#2 is rosette address			)
				(#3 is local next free address		)
	#3 = [#1 + 1 + ##1]  ( next free index)
	##3 = [#2]
	##1 = [##1 + 1]
o<AddRosetteToSpindle> endsub

(Interpolate between two values returns interpolated value in #<_result> )
( the first value must be less than the second value)
(parameters #1 = value 1)
(	    #2 = fraction )
(	    #3 = value 2 )
( returns value in global #<_result> )
o<linterp> sub
	#<_result> = [ #1 * [ 1 - #2 ] + [#3 * #2 ]] 
o<linterp> endsub

o<linterp2> sub	(param #1 is x1	)
		(param #2 is y1 )
		(param #3 is f	)
		(param #4 is x2 )
		(param #5 is y2 )

	#<_resultX> = [ #1 * [ 1 - #3 ] + [#3 * #4 ]] 
	#<_resultY> = [ #2 * [ 1 - #3 ] + [#3 * #5 ]]
o<linterp2> endsub

(  In all the following subs						)
( #1 first param is the rosette addr of data blockin EMC variables 	)
( #2 is angle to use to calculate the radius				)
( result is returned in global variable <_result>			)

o100 sub  (Elliptical Rosette Type = 0			)
	(param  #1 is address of data block		)
	(param  #2 is the angle of required radius	)
	(local  #3 is the major radius			)
	(local  #4 is the minor radius			)
	(local  #5 is the phase				)
	(local  #6 is the blend				)
	(local  #7 is phase corrected angle		)
	(local  #8 is bcos = Minor_rad * cos #7		)
	(local  #9 is asin = Major_rad * sin #7		)
	(local  #10 is l = sqrt[asin*asin + bcos*bcos]	)
 
	(first get values)
	#3 = #[#1 + 2]
	#4 = #[#1 + 3]
	#5 = #[#1 + 4]
	#6 = #[#1 + 5]

	#7 = [#2 - #5]
	(now calc radius of ellipse)
	o<ifer1> if [#3 EQ #4]
		#<_result> = [#3 * #6]    (always the same so save calc)		
	o<ifer1> else			
		#8 = [#4 * cos [ #7]]
		#9 = [#3 * sin [ #7]]
		#10 = [sqrt [ [#9 * #9] + [#8 * #8 ]]]
		#<_result> = [#6 * #3 * #4  / #10 ]
	o<ifer1> endif
	( also return 2D vector result )
	 #<_resultX> = [#<_result> * cos [#2]]
	 #<_resultY> = [#<_result> * sin [#2]]
o100 endsub

o150 sub	(Poly Rosette Type = 1			)  	
		(param #1 is Poly Rosette  address	)
		(param #2 is angl			)
		(local #3 is Major radius		)
		(local #4 is minor radius		)
		(local #5 is phase			)
		(local #6 is blend			)
		(local #7 is number of sides ns		)
		(local #8 is star flag = 1 if a star	)
	(first get values)
	#3	= #[#1 + 2]	(r1	)
	#4	= #[#1 + 3]	(r2 	)
	#5	= #[#1 + 4]	(phase 	)
	#6 	= #[#1 + 5]	(blend 	)
	#7 	= #[#1 + 6]	(ns	)
	#8 	= #[#1 + 7]	(isstar	)

	#9 = [#2 - #5]  (angle = angl - phase , correct for phase)

	#7 = [[ 1 + #8] * #7] 		(actual number of sides)
	#10 = [ 360 / #7]		(da )
	#11 = [#10 / 2 ]		(da2)
	#12 = [#9 / #10]		(f = angle / da )
	#13 = fix [ #12]		(indx = floor[f])
	#14  = [#9 - #13 * #10]		(fs = angle - indx * da )

	o<ifpr1> if [ #8 EQ 0 ]  (if !Isstar)
		O<ifpr02> if [#14 LT #11 EQ 0]		
		    #14 = [#11 - #14]  (fs = da2 - fs )
		o<ifpr02> else
		    #14 = [#14 - #11]  (fs = fs - da2 )
		   
		o<ifpr02> endif 
		#<_result> = [ #6 * #3 * cos[#11] /  cos [#14] ]
	o<ifpr1> else
		o<ifpr03> if [[#13 mod 2] eq 0] (swap r1 r2 )
		 #15 = [#3]
		 #3  = [#4]
		 #4  = [#15]
		o<ifpr03> endif
		#16 = [#3 - #4 * cos [#10]]  (l = r1 - r2 * cos [da])
		#17 = atan [#4 * sin[#10]] / [#16] (alpha = atan [ r2 * sin[da] / l )
		#<_result> = [#6 * #4 * sin [#10 + #17] / sin[#14 + #17]] (r = r2 * sin[da + alpha] / sin [fs + alpha])
	o<ifpr1> endif
	#<_resultX> = [#<_result> * cos [#2]]
	#<_resultY> = [#<_result> * sin [#2]]
o150 endsub

o200 sub  (Wave Rosette Type = 2 )
	( #1 is address of data block		)
	( #2 is the angle of required radius	)
	( #3 is the major radius		)
	( #4 is the frequency			)
	( #5 is the amplitude			)
	( #6 is the phase			)
	( #7 is the abs value			)
	( #8 is the blend value			)
	( #9 is amplitude at angle given by #2  )
	(first get values)
	#3	 = #[#1 + 2]
	#6	 = #[#1 + 4]
	#8	 = #[#1 + 5]
	#4	 = #[#1 + 6]
	#5	 = #[#1 + 7]
	#7	 = #[#1 + 8]
	#9 = [#5 * sin[#4 * [#2 - #6]]]
	o<ifwr1> if [#7 GT 0]
		#9 = abs[#9]
	o<ifwr1>  endif
	#<_result> = [#8 * [ #3 + #9]]
	#<_resultX> = [#<_result> * cos [#2]]
	#<_resultY> = [#<_result> * sin [#2]]
o200 endsub

o250 sub (Epicycloid Rosette Type = 3)
		( param #1 is address of data block		)
		( param #2 is the angle of required radius	)
		( local #3 is the major radius	R		)
		( local #4 is the minor radius	r		)
		( local #5 is the phase				)
		( local #6 is the blend				)
		( local #7 is k + 1				)
		( local #8 is x					)
		( local #9 is y					)
		( local #10 is angle - phase			)
	(first get values)
	#3	 = #[#1 + 2]
	#4	 = #[#1 + 3]
	#5	 = #[#1 + 4]
	#6	 = #[#1 + 5]

	#10 = [#2 - #5]  (correct for phase)

	#7 = [#3 / #4 + 1]
	#8 = [#4 * #7 * cos [#10] - #4 * cos [#7 * #10]]
	#9 = [#4 * #7 * sin [#10] - #4 * sin [#7 * #10]]

	#<_result> = sqrt[[#8 * #8] + [#9 * #9]]
	#<_result> = [#<_result> * #6]
	#<_resultX> = [#8 * #6]
	#<_resultY> = [#9 * #6]
o250 endsub

o300 sub (HypoCycloid Rosette  Type = 4)
		( param #1 is address of data block		)
		( param #2 is the angle of required radius	)
		( local #3 is the major radius			)
		( local #4 is the minor radius			)
		( local #5 is the phase				)
		( local #6 is the blend				)
		( local #7 is k - 1				)
		( local #8 is x					)
		( local #9 is y					)
		( local #10 is angle - phase			)
	( k = R / r )
	( x = r * [k - 1]cos θ + r cos [[k-1] θ] )
	( y = r * [k - 1]sin θ - r sin [[k-1] θ] )
	
	(first get values)
	#3	 = #[#1 + 2]
	#4	 = #[#1 + 3]
	#5	 = #[#1 + 4]
	#6	 = #[#1 + 5]

	#10 = [#2 - #5]  (correct for phase)

	#7 = [#3 / #4 - 1]
	#8 = [#4 * #7 * cos [#10] + #4 * cos [#7 * #10]]
	#9 = [#4 * #7 * sin [#10] - #4 * sin [#7 * #10]]
	#<_result> = sqrt[[#8 * #8] + [#9 * #9]]
	#<_result> = [#<_result> * #6]
	#<_resultX> = [#8 * #6]
	#<_resultY> = [#9 * #6]
o300 endsub

o350 sub (Spiral Rosette Type = 5)
		( param #1 is address of data block		)
		( param #2 is the angle of required radius	)

		( r = a + b * angle				)
		( local #3 is a					)
		( local #4 is b					)
		( local #5 is the phase				)
		( local #6 is the blend				)
	
	#3	= #[#1 + 2]
	#4	= #[#1 + 3]
	#5	= #[#1 + 4]
	#6	= #[#1 + 5]

	#<angl> = [#2 - #5]  (correct for phase)
	#<_result> = [#6 * [ #3 + [ #4 * #2]]]
	#<_resultX> = [#<_result> * cos [#2]]
	#<_resultY> = [#<_result> * sin [#2]]
o350 endsub

o400 sub  (Petal Rosette Type = 6)
		(param #1 is Rosette  address	)
		(param #2 is angl			)
		(local #3 is Major radius		)
		(local #4 is minor radius		)
		(local #5 is phase			)
		(local #6 is blend			)
		(local #7 is number of sides ns		)
	
	(first get values)
	#3	= #[#1 + 2]	(r1	)
	#4	= #[#1 + 3]	(r2 	)
	#5	= #[#1 + 4]	(phase 	)
	#6 	= #[#1 + 5]	(blend 	)
	#7 	= #[#1 + 6]	(ns	)
	(debug in petal blend is #6 ns is #7 r1 is #3 r2 is #4)
	#9 = [#2 - #5]  (angle = angl - phase , correct for phase)

	#7 =  [2 * #7] 			(actual number of sides)
	#10 = [ 360 / #7]		(da )
	#11 = [#10 / 2 ]		(da2)
	#12 = [#9 / #10]		(f = angle / da )
	#13 = fix [ #12]		(indx = floor[f])
	#14  = [#9 - #13 * #10]		(fs = angle - indx * da )

	O<ifpr02> if [[#13 mod 2] EQ 0]		
		    o<linterp> call [#3] [#14 / #10] [#4] 
	o<ifpr02> else
		    o<linterp> call [#3] [1 - #14 / #10] [#4]
	o<ifpr02> endif	
	#<_result> = [ #<_result> * #6]
	(debug petal r = #<_result>)
	#<_resultX> = [#<_result> * cos [#2]]
	#<_resultY> = [#<_result> * sin [#2]]
o400 endsub

o450 sub (Formula Rosette ID = 7 )
	(not implemented yet)
	(debug, not implemented)
	#<_result> = 0
	#<_resultX> = 0
	#<_resultY> = 0
o450 endsub

(sub to calculate the blending total for a spindle			)
o<Blend_total> sub	(#1 is addr of spindle				)
			(#2 is local index rindx			)
			(#3 is local address of rosette 		)
			(#4 is local number of rosettes			)
			(#5 is the running total			)
	#2 = 0
	#5 = 0
	#4 = ##1
	
	o<sowhile> while [#2 LT ##1]
		#3 = #[#1 + 1 + #2]
		#5 = [ #5 + abs[ #[#3 + 5]]]
		#2 = [ #2 + 1]
	o<sowhile> endwhile
	#<_result> = [#5]
o<Blend_total> endsub

( sub to calculate the amount a headstock moves due to the action of a rosette  )
o<Spindle_Offset> sub 	( param #1 is the spindle concerned			)
			( param #2 is the angle concerned			)
			( local #3 is rindx viz index through spindle		) 
			( local #4 is r = overall radius 			)
			( local #5 is rs = radius of an individual rosette	) 
			( local #6 is calculated address of rosette		)
			( local #7 is rosette type				)
			( local #8 is blend total				)
	o<ifso> if [##1 EQ 0] (Spindle empty)
		#<_result> = 0
		#<_resultX> = 0
		#<_resultY> = 0
	o<ifso> else
		#3 = 0
		o<ifso0> if [#<_UseBlending> EQ 1] (initialise r )
			#4 = 0
			o<Blend_total> call [#1]
			#8 = [#<_result>]
		o<ifso0> else
			#4 = -200
			#8 = 1
		o<ifso0> endif	

		o<sowhile> while [#3 LT ##1]
			#6 = #[#1 + 1 + #3]
			#7 = ##6
			#9 = [100 + #7 * 50]
			o[100 + 50 * #7] call [#6] [#2]	(call relevant rosette)		
			#5 = [#<_result>]
		
			(what we do now depends upon blend flag)
			o<ifso1> if [#<_UseBlending> GT 0 ]	
				#4 = [ #4 + #5]
			o<ifso1> else  (not using blending so just max)
				o<ifso11> if [#5 GT #4]
					#4 = [#5]
				o<ifso11> endif
			o<ifso1> endif
			#3 = [ #3 + 1]
		o<sowhile> endwhile
		#<_result> = [#4 / #8]
	o<ifso> endif
o<Spindle_Offset> endsub

(********************* Geometric Chuck Code ****************************)
( Basic offsets for a Chuck stage record				)
( C_Vin		= 0			Velocity of previous stage	)
( C_Vout	= 1			Velocity of current stage	)
( C_Dirn	= 2			+1 or -1 for rotation direction	)
( C_Rosette	= 3			address of Rosette record	)

( Record Sizes								)
#<_COffset>	= 4	( Size of record for a chuck stage		)
o<Display_Stage> sub ( param #1 is address of stage )
	#2 = ##1 
	#3 = #[#1 + 1]
	#4 = #[#1 + 2]
	#5 = #[#1 + 3]
	(debug, stage vin = #2 vout = #3 dirn = #4 rosette = #5)
o<Display_Stage> endsub

(Subroutine to create a new stage and add to chuck			)
o<Create_Chuck_Stage> sub
			(param #1 is vin				)
			(param #2 is vout				)
			(param #3 is same dirn flag			)
			(param #4 is address of rosette			)
			(local #6 is next free address			)
	#6 = [#<_Chuck> + 1 + #<_Chuck_Count> * #<_COffset>]  ( next free index)
	##6	= [#1]
	#[#6+1] = [#2]
	#[#6+2]	= [#3]
	#[#6+3] = [#4]
	#<_Chuck_Count> = [ #<_Chuck_Count> + 1]
	#<_result> = [#6]

o<Create_Chuck_Stage> endsub

( Subroutines for calculating chuck position				)
o<Stage_out_angle> sub		
			(param #1 is address of stage			)
			(param #2 is angle of prev stage		)
			(local #3 is vin				)
			(local #4 is vout				)
			(local #5 is dirn				)
			
	#3	= ##1
	#4	= #[#1 + 1]
	#5	= #[#1 + 2]
	#<_result> = [[ #4 / #3 ] * #2 * #5]
o<Stage_Out_angle> endsub

o<Quadrant> sub 
		(param #1 is x )
		(param #2 is y )
	
	#<_result> = 0
	o<ifq1> if [[#1 LT 0] AND [#2 GE 0]]
		#<_result> = 1
	o<ifq1> endif
	o<ifq2> if [[#1 LT 0] AND [#2 LT 0]]
		#<_result> = 2
	o<ifq2> endif
	o<ifq3> if [[#1 GE 0] AND [#2 LT 0]]
		#<_result> = 3
	o<ifq3> endif
o<Quadrant> endsub

o<Polar> sub
		(param #1 is x	)
		(param #2 is y  )

		#3 = [#1 * #1]
		#4 = [#2 * #2]
				
		#<_resultA> = [ atan [#2] / [#1]]
		o<ifp> if [#<_resultA> LT 0]
			#<_resultA> = [ #<_resultA> + 360]
		o<ifp> endif
		#<_result> = sqrt[ #3 + #4]
o<Polar> endsub

( Calculate position of chuck for given angle			)
o<Chuck_Vector> sub	
		(param #1 is angle				)
		(local #3 is index to stages			)
		(local #4 is address of current stage		)
		(local #5 is address of rosette			)
		(local #6 is type of rosette			)
		(local #7 is out angle of stage			)

		(local #8 is total x value			)
		(local #9 is total y value			)
		
	#3 = 0		(indx = 0)
	#8 = 0		(total total x = 0 )
	#9 = 0		(total total y = 0 )
	#7 = [#1] 	(stage angle = initial angle)
	(debug stages = #<_Chuck_Count> angle = #7) 
 	o<whilecv> while [#3 LT #<_Chuck_Count> ]
		#4 = [ #<_Chuck> + 1 + #3 * #<_COffset>]  (address of stage)
		#5 = [#[#4 + 3]]   (address of rosette )
		#6 = [##5]
		o<Stage_out_angle> call [#4] [#7]
		#7 = [#<_result>]
		o[100 + 50 * #6] call [#5] [#7]	(call relevant rosette)	
		(debug angle = #7 x = #<_resultX> y = #<_resultY> )
		#8 = [#8 + #<_resultX>] ( add xcoord of this stage to total )
		#9 = [#9 + #<_resultY>]
		
		#3 = [#3 + 1]
	o<whilecv> endwhile
	#<_resultX> = [#8]
	#<_resultY> = [#9]
	o<Polar> call [#8] [#9]
o<Chuck_Vector> endsub
(***********************************************************************)
(******Next Section is movement so change to suit your axis layout *****)
( In my setup the 4 axes of my machine are 				)
(	cnc x = rose x rosette movement					)
(	cnc y = rose z pumping movement					)
(	cnc v = rose v  for depth of cut				)
(	cnc b = rose c for rotation of spindle				)

o<MoveTo> sub	(param #1 is rose x which is the headstock x offset	)	
		(param #2 is rose y which is the headstock y offset	)
		(param #3 is rose z which is the pumping offset		)
		(param #4 is rose c which is angle			)
		(param #5 is rose v which is the depth to cut at	)
		(param #6 is F which is the feedrate			)

		(local #7 is polar Radius if using rotary table		)
		(local #8 is polar Angle  if using rotary table		) 
		(local #9 is int number of rotations			)

	o<ifmt0> if [#<_UseRotary> GT 0]
			o<Polar> call [#1] [#2]
			#7 = [#<_result>]
			#8 = [#<_resultA> + #<_Winding> * 360 ] 
			
	o<ifmt0> endif

	o<ifmt> if [[#<_UseMainSpindle> EQ 1] AND [#<_UsePumpSpindle> EQ 1]]
		o<ifmt1> if [#<_UseRotary GT 0]
			g1 x[#7] b[#8] y[#3] v[#5] f[#6] (my setup change for yours)
		o<ifmt1> else
			g1 x[#1] y[#2] z[#3] c[#4] v[#5] f[#6]
		o<ifmt1> endif
	o<ifmt> else
		o<ifmt2> if [#<_UseMainSpindle> EQ 1]
			o<ifmt3> if [#<_UseRotary> GT 0]
				g1 x[#7] b[#8] v[#5] f[#6] (my setup change for yours)
			o<ifmt3> else
		 		g1 x[#1] y[#2] b[#4] v[#5] f[#6]
			o<ifmt3> endif
		o<ifmt2> else
			o<ifmt4> if [#<_UsePumpSpindle> EQ 1]
				g1 y[#3] b[#4] v[#5] f[#6]  (Change if necessary)
			o<ifmt4> endif
		o<ifmt2> endif
	o<ifmt> endif
	
o<MoveTo> endsub

o<GoTo> sub	(param #1 is rose x which is the headstock x offset		)	
		(param #2 is rose y which is the headstock y offset		)
		(param #3 is rose z which is the pumping offset			)
		(param #4 is rose c which is the angle round the spindle	)
		(param #5 is rose v which is the depth to cut at		)
		(param #6 is F which is the feedrate				)

		(local #7 is polar Radius if using rotary table			)
		(local #8 is polar Angle  if using rotary table			) 

	o<ifgt0> if [#<_UseRotary> GT 0]
		o<Polar> call [#1] [#2]
		#7 = [#<_result>]
		#8 = [#<_resultA> + #<_Winding> * 360 ] 			
	o<ifgt0> endif
	
	o<ifgt> if [[#<_UseMainSpindle> EQ 1] AND [#<_UsePumpSpindle> EQ 1]]
		o<ifgt1> if [#<UseRotary GT 0]
			g0 x[#7] b[#8] y[#3] v[#5] f[#6] (my setup change for yours)
		o<ifgt1> else
			g0 x[#1] y[#2] z[#3] b[#4] v[#5] f[#6]
		o<ifgt1> endif
	o<ifgt> else
		o<ifgt2> if [#<_UseMainSpindle> EQ 1]
			o<ifgt3> if [#<_UseRotary> GT 0]
				g0 x[#7] b[#8] v[#5] f[#6]
			o<ifgt3> else
		 		g0 x[#1] y[#2] v[#3] b[#4] f[#5]
			o<ifgt3> endif
		o<ifgt2> endif
		o<ifgt4> if [#<_UsePumpSpindle> EQ 1]
			g0 y[#2] v[#3] b[#4] f[#5]
		o<ifgt4> endif
	o<ifgt> endif
	
o<GoTo> endsub

o<MoveToSafeHeight> sub
	o<ifmts> if [#<_UseRotary> GT 0]
		g0 V [#<_Safeheight>]
	o<ifmts> else (using xy plane Z for depth)
		g0 Z [#<_Safeheight>]
	o<ifmts> endif
o<MoveToSafeHeight> endsub

o<MoveToDepth> sub 	(#1 is depth )
			(#2 is feedrate )
	o<ifmtd> if [#<_UseRotary> GT 0]
		g0 V 0
		g1 V [#1] f[#2]
	o<ifmtd> else
		g0 Z 0
		g1 Z [#1] f[#2]
	o<ifmtd> endif
o<MoveToDepth> endsub

(******* End of user configurable section **************************************)
(function gcd[a, b]	)
(    while b ? 0	)
(       t := b		)
(       b := a mod b	)
(       a := t		)
(    return a		)

o<GCD> sub
	( param #1 is a )
	( param #2 is b )
	( local #3 is t	)
	o<whilegcd> while [ #2 NE 0]
		#3 = [#2]
		#2 = [ #1 mod #2]
		#1 = #3
	o<whilegcd> endwhile
	#<_result> = [#1]
o<GCD> end sub

( Returns the number of turns of spindle required for chuck 	)
( Many thanks to Bruce for his advice				)
o<NTurns> sub
	(local #1 is N 			)
	(local #2 is D			)
	(local #3 is stage counter	)
	(local #4 is stage address	)
	(local #5 is divisor		)
	(local #6 is Nstage		)
	(local #7 is D stage		)
	#<_result> = 1  (default value )
	o<ifnt1> if [ #<_Chuck_Count>GT 1 ]  need to calc num turns )
		#1 = [1]
		#2 = [1]
		#3 = [0]
		o<ntwhile1>while [#3 LT #<_Chuck_Count> ]
			#4 = [ #<_Chuck> + 1 + #3 * #<_COffset>]  (address of stage)
			#6 = [##4]		(n stage 		)
			#7 = [#[#4+1]]		(d stage 		)
			o<GCD> call [#6] [#2]	(gcd  n D 		)
			#5 = [#<_result>]
			#1 = [ #1 * #6 * #5 ]	( N = N * n / divisor 	)
			#2 = [ #2 / #5 * #7 ]	( D = D / divisor * d 	)
			#3 = [#3 + 1]
		o<ntwhile1> endwhile
		#<_result> = [#1]
	o<ifnt1> endif
o<NTurns> endsub
(*******************************************************************************)
( Model of rose engine assumes the following physical configuration		)
(	X is lateral axis for headstock lateral movement			)
(	Y is vertical axis for headstock movement				)
(	Z is axis along spindle for pumping movement				)
(	C is rotation of spindle axis						)
(	B is axis of rotation of cutter						)
(	U is axis to use for tool movement towards spindle i.e YZ plane		)
(	W is axis to use for tool movement towards face i.e XY plane		)
(										)
( You can map these onto a different set of CNC axes using the section above	)
(*******************************************************************************)
  
o<Generate_Path> sub  	(param #1 is start angle			)
			(param #2 in angle increment			)
			(param #3 is end angle				)
			(param #4 is feedrate				)
			(param #5 is tool offset			)
			(param #6 is the depth to cut at		)
			(param #7 is phase of main spindle		)
			(param #8 is phase of pump spindle		)
		
			(local #10 is local angle			)
			(local #11 is x	headstock lateral  movement	)
			(local #12 is y	headstock vertical movement     )
			(local #13 is z headstock pumping movement	)
			(local #14 is Quadrant of last point		) 
			(local #15 is Quadrant of current point		)
			(local #16 is corrected angle			)

	#10 = [#1]
	#11 = 0		
	#12 = 0	
	#13 = 0	
	#14 = -1		( this means no value 			)
	#15 = -1
	#<_Winding> = 0		( zero times around origin		)
	o<GenWhile> while [ #10 LE #3 ]
		
		o<ifmain> if [#<_UseMainSpindle> EQ 1]
			o<Spindle_Offset> call [#<_MainSpindle>] [#10 + #7]
			#11 = [#<_result>]
			#12 = [0]	
		o<ifmain> else
			#11 = [0]
			#12 = [0]		
		o<ifmain> endif
		o<ifmain0> if [#<_UseChuck>]
			o<Chuck_Vector> call [#10 + #7]
			( now do something with result )
			o<ifmain01> if [#<_UseMainSpindle> EQ 1]
				#11 = [#11 + #<_resultX>]
				#12 = [#12 + #<_resultY>]
			o<ifmain01> else
				#11 = [#<_resultX>]
				#12 = [#<_resultY>]	
			o<ifmain01> endif
		o<ifmain0> endif
		o<ifpump> if [#<_UsePumpSpindle> EQ 1]
			o<Spindle_Offset> call [#<_PumpSpindle>] [#10 + #8]
			#13 = #<_result>
		o<ifpump> endif
		( now generate call to move along path 	)
		( first establish angle			)
		o<Quadrant> call [#11] [#12]
		#15 = [#<_result>]  ( Current quadrant )
		o<ifmain4> if [#<_UseRotary> GT 0]
			o<ifmain5> if [#14 LT 0]
				#14 = [#15]
			o<ifmain5> else (check if wound around axis )
					(assumes only a very small angle movement )
				o<ifmain6> if [[#14 EQ 3] AND [#15 EQ 0]] (completed rotation)
					#<_Winding> = [#<_Winding> + 1]
				o<ifmain6> endif
			o<ifmain5> endif
		o<ifmain4> endif	
		#14 = [#15]  (remember current quadrant )
		o<ifmain2> if [#10 EQ #1] (move at safe height to point)
			o<MoveToSafeHeight> call
			o<GoTo> call [#11 * #<_XScale>] [#12 * #<_YScale>] [#13] [#10] [#<_Safeheight>] [#4]
					(params x,y,z,c,v,f)
			o<MoveToDepth> call [#6] [#4]
		o<ifmain2> else
			o<MoveTo> call [#11 * #<_XScale>] [#12 * #<_YScale> ] [#13] [#10] [#6] [#4] 
					(x,y,z,c,v,f)
		o<ifmain2> endif	
		#10 = [#10 + #2]
	o<GenWhile> endwhile
	o<MoveToSafeHeight> call
o<Generate_Path> endsub



(---------------------- Start of main program --------------------------)
#<_XScale>		= 1	( x scale factor			)
#<_YScale>		= 1	( y scale factor			)
#<_ZScale>		= 1	( z scale factor , I never use		)	
#<_UseRotary>		= 1	(we are using a rotary machine		)
#<_UseMainSpindle> 	= 1	(we are using main spindle		)
#<_UsePumpSpindle> 	= 0	( not using pump			)
#<_UseChuck>		= 1	(not using a chuck			)
#<_UseBlending>		= 0	(blending rosettes			)

#<ToolOffset>		= 0	(tool at centre of work			)
#<_Safeheight>		= 2	(Safe height				)
#<Feedrate>		= 60	( Linear Feed rate			)
#<nturns>		= 1	( number of spindle turns required	)

( now must add at least one rosette to the spindle 			)
##<_MainSpindle> = 0		( spindle is empty			)
##<_PumpSpindle> = 0
##<_Chuck>	 = 0		(chuck is empty				)

(******** first create spindle, chuck etc ******************************)

/o<CreateEllipticalRosette> call [100] [50] [0] [1]  	(r1, r2, ph, bl)
/o<CreateWaveRosette> call [100] [6] [25] [0] [0] [1]	(r1, f,  a,  abs,  ph, bl)
/o<CreateWaveRosette> call [100] [6] [25] [1] [0] [1]	(r1, f,  a,  abs,  ph, bl)
/o<CreatePolyRosette> call [100] [80] [6] [0] [0] [1]	(r1, r2, ns, star, ph, bl)
/o<CreatePolyRosette> call [100] [20] [6] [1] [0] [1]	(r1, r2, ns, star, ph, bl)
/o<CreatePetalRosette> call [100] [20] [7] [0] [1]	(r1, r2, ns, ph, bl)
/o<CreateEpiRosette> call [120] [20] [0] [1]		(r1, r2, ph, bl)
/o<CreateHypoRosette> call [90] [15] [0] [1]		(r1, r2, ph, bl)
/o<CreateSpiralRosette> call [50] [0.5] [0] [1]		( a,  b, ph, bl)
/o<AddRosetteToSpindle> call [#<_MainSpindle>] [#<_result>]

(**** Testing chuck ****)
o<CreateEllipticalRosette> call [50] [50] [0] [1]  	(r1, r2, ph, bl)
o<Create_Chuck_Stage> call [2] [3] [1] [#<_result>]
o<CreateEllipticalRosette> call [20] [20] [30] [1]  	(r1, r2, ph, bl)
o<Create_Chuck_Stage> call [12] [13] [-1] [#<_result>]
(******************* Now create paths ***********************************)
o<main1> if [#<_UseRotary> EQ 1]
	g93  (Inverse time mode )
o<main1> endif
o<ifmain1> if [#<_UseChuck> GT 0]
	o<NTurns> call
	#<nturns> = [#<_result>]	
o<ifmain1> endif
o<Generate_Path> call [0] [1] [#<nturns> * 360 ] [#<Feedrate>] [#<ToolOffset>] [-2] [0] [0]
g92 b0  (dont unwind )
g0 x0 b0 v[#<_Safeheight>]
g92.1
M2